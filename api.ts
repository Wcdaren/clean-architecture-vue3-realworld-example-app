/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Conduit API
 * Conduit API
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'https://localhost/api'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface Article
 */
export interface Article {
  /**
   *
   * @type {string}
   * @memberof Article
   */
  slug: string
  /**
   *
   * @type {string}
   * @memberof Article
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof Article
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Article
   */
  body: string
  /**
   *
   * @type {Array<string>}
   * @memberof Article
   */
  tagList: Array<string>
  /**
   *
   * @type {Date}
   * @memberof Article
   */
  createdAt: Date
  /**
   *
   * @type {Date}
   * @memberof Article
   */
  updatedAt: Date
  /**
   *
   * @type {boolean}
   * @memberof Article
   */
  favorited: boolean
  /**
   *
   * @type {number}
   * @memberof Article
   */
  favoritesCount: number
  /**
   *
   * @type {Profile}
   * @memberof Article
   */
  author: Profile
}

/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
  /**
   *
   * @type {number}
   * @memberof Comment
   */
  id: number
  /**
   *
   * @type {Date}
   * @memberof Comment
   */
  createdAt: Date
  /**
   *
   * @type {Date}
   * @memberof Comment
   */
  updatedAt: Date
  /**
   *
   * @type {string}
   * @memberof Comment
   */
  body: string
  /**
   *
   * @type {Profile}
   * @memberof Comment
   */
  author: Profile
}

/**
 *
 * @export
 * @interface GenericErrorModel
 */
export interface GenericErrorModel {
  /**
   *
   * @type {any}
   * @memberof GenericErrorModel
   */
  errors: any
}

/**
 *
 * @export
 * @interface LoginUser
 */
export interface LoginUser {
  /**
   *
   * @type {string}
   * @memberof LoginUser
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof LoginUser
   */
  password: string
}

/**
 *
 * @export
 * @interface LoginUserRequest
 */
export interface LoginUserRequest {
  /**
   *
   * @type {LoginUser}
   * @memberof LoginUserRequest
   */
  user: LoginUser
}

/**
 *
 * @export
 * @interface MultipleArticlesResponse
 */
export interface MultipleArticlesResponse {
  /**
   *
   * @type {Array<Article>}
   * @memberof MultipleArticlesResponse
   */
  articles: Array<Article>
  /**
   *
   * @type {number}
   * @memberof MultipleArticlesResponse
   */
  articlesCount: number
}

/**
 *
 * @export
 * @interface MultipleCommentsResponse
 */
export interface MultipleCommentsResponse {
  /**
   *
   * @type {Array<Comment>}
   * @memberof MultipleCommentsResponse
   */
  comments: Array<Comment>
}

/**
 *
 * @export
 * @interface NewArticle
 */
export interface NewArticle {
  /**
   *
   * @type {string}
   * @memberof NewArticle
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof NewArticle
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof NewArticle
   */
  body: string
  /**
   *
   * @type {Array<string>}
   * @memberof NewArticle
   */
  tagList?: Array<string>
}

/**
 *
 * @export
 * @interface NewArticleRequest
 */
export interface NewArticleRequest {
  /**
   *
   * @type {NewArticle}
   * @memberof NewArticleRequest
   */
  article: NewArticle
}

/**
 *
 * @export
 * @interface NewComment
 */
export interface NewComment {
  /**
   *
   * @type {string}
   * @memberof NewComment
   */
  body: string
}

/**
 *
 * @export
 * @interface NewCommentRequest
 */
export interface NewCommentRequest {
  /**
   *
   * @type {NewComment}
   * @memberof NewCommentRequest
   */
  comment: NewComment
}

/**
 *
 * @export
 * @interface NewUser
 */
export interface NewUser {
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  password: string
}

/**
 *
 * @export
 * @interface NewUserRequest
 */
export interface NewUserRequest {
  /**
   *
   * @type {NewUser}
   * @memberof NewUserRequest
   */
  user: NewUser
}

/**
 *
 * @export
 * @interface Profile
 */
export interface Profile {
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  bio: string
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image: string
  /**
   *
   * @type {boolean}
   * @memberof Profile
   */
  following: boolean
}

/**
 *
 * @export
 * @interface ProfileResponse
 */
export interface ProfileResponse {
  /**
   *
   * @type {Profile}
   * @memberof ProfileResponse
   */
  profile: Profile
}

/**
 *
 * @export
 * @interface SingleArticleResponse
 */
export interface SingleArticleResponse {
  /**
   *
   * @type {Article}
   * @memberof SingleArticleResponse
   */
  article: Article
}

/**
 *
 * @export
 * @interface SingleCommentResponse
 */
export interface SingleCommentResponse {
  /**
   *
   * @type {Comment}
   * @memberof SingleCommentResponse
   */
  comment: Comment
}

/**
 *
 * @export
 * @interface TagsResponse
 */
export interface TagsResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof TagsResponse
   */
  tags: Array<string>
}

/**
 *
 * @export
 * @interface UpdateArticle
 */
export interface UpdateArticle {
  /**
   *
   * @type {string}
   * @memberof UpdateArticle
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof UpdateArticle
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof UpdateArticle
   */
  body?: string
}

/**
 *
 * @export
 * @interface UpdateArticleRequest
 */
export interface UpdateArticleRequest {
  /**
   *
   * @type {UpdateArticle}
   * @memberof UpdateArticleRequest
   */
  article: UpdateArticle
}

/**
 *
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  token?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  bio?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  image?: string
}

/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
  /**
   *
   * @type {UpdateUser}
   * @memberof UpdateUserRequest
   */
  user: UpdateUser
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  token: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  bio: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  image: string
}

/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   *
   * @type {User}
   * @memberof UserResponse
   */
  user: User
}

/**
 * ArticlesApi - fetch parameter creator
 * @export
 */
export const ArticlesApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Create an article. Auth is required
     * @summary Create an article
     * @param {NewArticleRequest} article Article to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticle(article: NewArticleRequest, options: any = {}): FetchArgs {
      // verify required parameter 'article' is not null or undefined
      if (article === null || article === undefined) {
        throw new RequiredError(
          'article',
          'Required parameter article was null or undefined when calling createArticle.'
        )
      }
      const localVarPath = `/articles`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'NewArticleRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(article || {})
        : article || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an article. Auth is required
     * @summary Delete an article
     * @param {string} slug Slug of the article to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticle(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling deleteArticle.'
        )
      }
      const localVarPath = `/articles/{slug}`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get an article. Auth not required
     * @summary Get an article
     * @param {string} slug Slug of the article to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticle(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling getArticle.'
        )
      }
      const localVarPath = `/articles/{slug}`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get most recent articles globally. Use query parameters to filter results. Auth is optional
     * @summary Get recent articles globally
     * @param {string} [tag] Filter by tag
     * @param {string} [author] Filter by author (username)
     * @param {string} [favorited] Filter by favorites of a user (username)
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticles(
      tag?: string,
      author?: string,
      favorited?: string,
      limit?: number,
      offset?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/articles`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag
      }

      if (author !== undefined) {
        localVarQueryParameter['author'] = author
      }

      if (favorited !== undefined) {
        localVarQueryParameter['favorited'] = favorited
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
     * @summary Get recent articles from users you follow
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticlesFeed(
      limit?: number,
      offset?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/articles/feed`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an article. Auth is required
     * @summary Update an article
     * @param {string} slug Slug of the article to update
     * @param {UpdateArticleRequest} article Article to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(
      slug: string,
      article: UpdateArticleRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling updateArticle.'
        )
      }
      // verify required parameter 'article' is not null or undefined
      if (article === null || article === undefined) {
        throw new RequiredError(
          'article',
          'Required parameter article was null or undefined when calling updateArticle.'
        )
      }
      const localVarPath = `/articles/{slug}`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UpdateArticleRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(article || {})
        : article || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create an article. Auth is required
     * @summary Create an article
     * @param {NewArticleRequest} article Article to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticle(
      article: NewArticleRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleArticleResponse> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).createArticle(article, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Delete an article. Auth is required
     * @summary Delete an article
     * @param {string} slug Slug of the article to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticle(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).deleteArticle(slug, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get an article. Auth not required
     * @summary Get an article
     * @param {string} slug Slug of the article to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticle(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleArticleResponse> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).getArticle(slug, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get most recent articles globally. Use query parameters to filter results. Auth is optional
     * @summary Get recent articles globally
     * @param {string} [tag] Filter by tag
     * @param {string} [author] Filter by author (username)
     * @param {string} [favorited] Filter by favorites of a user (username)
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticles(
      tag?: string,
      author?: string,
      favorited?: string,
      limit?: number,
      offset?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<MultipleArticlesResponse> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).getArticles(tag, author, favorited, limit, offset, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
     * @summary Get recent articles from users you follow
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticlesFeed(
      limit?: number,
      offset?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<MultipleArticlesResponse> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).getArticlesFeed(limit, offset, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Update an article. Auth is required
     * @summary Update an article
     * @param {string} slug Slug of the article to update
     * @param {UpdateArticleRequest} article Article to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(
      slug: string,
      article: UpdateArticleRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleArticleResponse> {
      const localVarFetchArgs = ArticlesApiFetchParamCreator(
        configuration
      ).updateArticle(slug, article, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Create an article. Auth is required
     * @summary Create an article
     * @param {NewArticleRequest} article Article to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticle(article: NewArticleRequest, options?: any) {
      return ArticlesApiFp(configuration).createArticle(article, options)(
        fetch,
        basePath
      )
    },
    /**
     * Delete an article. Auth is required
     * @summary Delete an article
     * @param {string} slug Slug of the article to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticle(slug: string, options?: any) {
      return ArticlesApiFp(configuration).deleteArticle(slug, options)(
        fetch,
        basePath
      )
    },
    /**
     * Get an article. Auth not required
     * @summary Get an article
     * @param {string} slug Slug of the article to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticle(slug: string, options?: any) {
      return ArticlesApiFp(configuration).getArticle(slug, options)(
        fetch,
        basePath
      )
    },
    /**
     * Get most recent articles globally. Use query parameters to filter results. Auth is optional
     * @summary Get recent articles globally
     * @param {string} [tag] Filter by tag
     * @param {string} [author] Filter by author (username)
     * @param {string} [favorited] Filter by favorites of a user (username)
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticles(
      tag?: string,
      author?: string,
      favorited?: string,
      limit?: number,
      offset?: number,
      options?: any
    ) {
      return ArticlesApiFp(configuration).getArticles(
        tag,
        author,
        favorited,
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
     * @summary Get recent articles from users you follow
     * @param {number} [limit] Limit number of articles returned (default is 20)
     * @param {number} [offset] Offset/skip number of articles (default is 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticlesFeed(limit?: number, offset?: number, options?: any) {
      return ArticlesApiFp(configuration).getArticlesFeed(
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     * Update an article. Auth is required
     * @summary Update an article
     * @param {string} slug Slug of the article to update
     * @param {UpdateArticleRequest} article Article to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(slug: string, article: UpdateArticleRequest, options?: any) {
      return ArticlesApiFp(configuration).updateArticle(
        slug,
        article,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
  /**
   * Create an article. Auth is required
   * @summary Create an article
   * @param {NewArticleRequest} article Article to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public createArticle(article: NewArticleRequest, options?: any) {
    return ArticlesApiFp(this.configuration).createArticle(article, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Delete an article. Auth is required
   * @summary Delete an article
   * @param {string} slug Slug of the article to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public deleteArticle(slug: string, options?: any) {
    return ArticlesApiFp(this.configuration).deleteArticle(slug, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Get an article. Auth not required
   * @summary Get an article
   * @param {string} slug Slug of the article to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public getArticle(slug: string, options?: any) {
    return ArticlesApiFp(this.configuration).getArticle(slug, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Get most recent articles globally. Use query parameters to filter results. Auth is optional
   * @summary Get recent articles globally
   * @param {string} [tag] Filter by tag
   * @param {string} [author] Filter by author (username)
   * @param {string} [favorited] Filter by favorites of a user (username)
   * @param {number} [limit] Limit number of articles returned (default is 20)
   * @param {number} [offset] Offset/skip number of articles (default is 0)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public getArticles(
    tag?: string,
    author?: string,
    favorited?: string,
    limit?: number,
    offset?: number,
    options?: any
  ) {
    return ArticlesApiFp(this.configuration).getArticles(
      tag,
      author,
      favorited,
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
   * @summary Get recent articles from users you follow
   * @param {number} [limit] Limit number of articles returned (default is 20)
   * @param {number} [offset] Offset/skip number of articles (default is 0)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public getArticlesFeed(limit?: number, offset?: number, options?: any) {
    return ArticlesApiFp(this.configuration).getArticlesFeed(
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Update an article. Auth is required
   * @summary Update an article
   * @param {string} slug Slug of the article to update
   * @param {UpdateArticleRequest} article Article to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public updateArticle(
    slug: string,
    article: UpdateArticleRequest,
    options?: any
  ) {
    return ArticlesApiFp(this.configuration).updateArticle(
      slug,
      article,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * CommentsApi - fetch parameter creator
 * @export
 */
export const CommentsApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Create a comment for an article. Auth is required
     * @summary Create a comment for an article
     * @param {string} slug Slug of the article that you want to create a comment for
     * @param {NewCommentRequest} comment Comment you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleComment(
      slug: string,
      comment: NewCommentRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling createArticleComment.'
        )
      }
      // verify required parameter 'comment' is not null or undefined
      if (comment === null || comment === undefined) {
        throw new RequiredError(
          'comment',
          'Required parameter comment was null or undefined when calling createArticleComment.'
        )
      }
      const localVarPath = `/articles/{slug}/comments`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'NewCommentRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(comment || {})
        : comment || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a comment for an article. Auth is required
     * @summary Delete a comment for an article
     * @param {string} slug Slug of the article that you want to delete a comment for
     * @param {number} id ID of the comment you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleComment(
      slug: string,
      id: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling deleteArticleComment.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteArticleComment.'
        )
      }
      const localVarPath = `/articles/{slug}/comments/{id}`
        .replace(`{${'slug'}}`, encodeURIComponent(String(slug)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the comments for an article. Auth is optional
     * @summary Get comments for an article
     * @param {string} slug Slug of the article that you want to get comments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticleComments(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling getArticleComments.'
        )
      }
      const localVarPath = `/articles/{slug}/comments`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a comment for an article. Auth is required
     * @summary Create a comment for an article
     * @param {string} slug Slug of the article that you want to create a comment for
     * @param {NewCommentRequest} comment Comment you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleComment(
      slug: string,
      comment: NewCommentRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleCommentResponse> {
      const localVarFetchArgs = CommentsApiFetchParamCreator(
        configuration
      ).createArticleComment(slug, comment, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Delete a comment for an article. Auth is required
     * @summary Delete a comment for an article
     * @param {string} slug Slug of the article that you want to delete a comment for
     * @param {number} id ID of the comment you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleComment(
      slug: string,
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CommentsApiFetchParamCreator(
        configuration
      ).deleteArticleComment(slug, id, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get the comments for an article. Auth is optional
     * @summary Get comments for an article
     * @param {string} slug Slug of the article that you want to get comments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticleComments(
      slug: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<MultipleCommentsResponse> {
      const localVarFetchArgs = CommentsApiFetchParamCreator(
        configuration
      ).getArticleComments(slug, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Create a comment for an article. Auth is required
     * @summary Create a comment for an article
     * @param {string} slug Slug of the article that you want to create a comment for
     * @param {NewCommentRequest} comment Comment you want to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleComment(
      slug: string,
      comment: NewCommentRequest,
      options?: any
    ) {
      return CommentsApiFp(configuration).createArticleComment(
        slug,
        comment,
        options
      )(fetch, basePath)
    },
    /**
     * Delete a comment for an article. Auth is required
     * @summary Delete a comment for an article
     * @param {string} slug Slug of the article that you want to delete a comment for
     * @param {number} id ID of the comment you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleComment(slug: string, id: number, options?: any) {
      return CommentsApiFp(configuration).deleteArticleComment(
        slug,
        id,
        options
      )(fetch, basePath)
    },
    /**
     * Get the comments for an article. Auth is optional
     * @summary Get comments for an article
     * @param {string} slug Slug of the article that you want to get comments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticleComments(slug: string, options?: any) {
      return CommentsApiFp(configuration).getArticleComments(slug, options)(
        fetch,
        basePath
      )
    },
  }
}

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
  /**
   * Create a comment for an article. Auth is required
   * @summary Create a comment for an article
   * @param {string} slug Slug of the article that you want to create a comment for
   * @param {NewCommentRequest} comment Comment you want to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentsApi
   */
  public createArticleComment(
    slug: string,
    comment: NewCommentRequest,
    options?: any
  ) {
    return CommentsApiFp(this.configuration).createArticleComment(
      slug,
      comment,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Delete a comment for an article. Auth is required
   * @summary Delete a comment for an article
   * @param {string} slug Slug of the article that you want to delete a comment for
   * @param {number} id ID of the comment you want to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentsApi
   */
  public deleteArticleComment(slug: string, id: number, options?: any) {
    return CommentsApiFp(this.configuration).deleteArticleComment(
      slug,
      id,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get the comments for an article. Auth is optional
   * @summary Get comments for an article
   * @param {string} slug Slug of the article that you want to get comments for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommentsApi
   */
  public getArticleComments(slug: string, options?: any) {
    return CommentsApiFp(this.configuration).getArticleComments(slug, options)(
      this.fetch,
      this.basePath
    )
  }
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get tags. Auth not required
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsGet(options: any = {}): FetchArgs {
      const localVarPath = `/tags`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get tags. Auth not required
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsGet(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TagsResponse> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).tagsGet(options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Get tags. Auth not required
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsGet(options?: any) {
      return DefaultApiFp(configuration).tagsGet(options)(fetch, basePath)
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get tags. Auth not required
   * @summary Get tags
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tagsGet(options?: any) {
    return DefaultApiFp(this.configuration).tagsGet(options)(
      this.fetch,
      this.basePath
    )
  }
}

/**
 * FavoritesApi - fetch parameter creator
 * @export
 */
export const FavoritesApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Favorite an article. Auth is required
     * @summary Favorite an article
     * @param {string} slug Slug of the article that you want to favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleFavorite(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling createArticleFavorite.'
        )
      }
      const localVarPath = `/articles/{slug}/favorite`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Unfavorite an article. Auth is required
     * @summary Unfavorite an article
     * @param {string} slug Slug of the article that you want to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleFavorite(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          'slug',
          'Required parameter slug was null or undefined when calling deleteArticleFavorite.'
        )
      }
      const localVarPath = `/articles/{slug}/favorite`.replace(
        `{${'slug'}}`,
        encodeURIComponent(String(slug))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Favorite an article. Auth is required
     * @summary Favorite an article
     * @param {string} slug Slug of the article that you want to favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleFavorite(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleArticleResponse> {
      const localVarFetchArgs = FavoritesApiFetchParamCreator(
        configuration
      ).createArticleFavorite(slug, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Unfavorite an article. Auth is required
     * @summary Unfavorite an article
     * @param {string} slug Slug of the article that you want to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleFavorite(
      slug: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SingleArticleResponse> {
      const localVarFetchArgs = FavoritesApiFetchParamCreator(
        configuration
      ).deleteArticleFavorite(slug, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Favorite an article. Auth is required
     * @summary Favorite an article
     * @param {string} slug Slug of the article that you want to favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticleFavorite(slug: string, options?: any) {
      return FavoritesApiFp(configuration).createArticleFavorite(slug, options)(
        fetch,
        basePath
      )
    },
    /**
     * Unfavorite an article. Auth is required
     * @summary Unfavorite an article
     * @param {string} slug Slug of the article that you want to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticleFavorite(slug: string, options?: any) {
      return FavoritesApiFp(configuration).deleteArticleFavorite(slug, options)(
        fetch,
        basePath
      )
    },
  }
}

/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
  /**
   * Favorite an article. Auth is required
   * @summary Favorite an article
   * @param {string} slug Slug of the article that you want to favorite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FavoritesApi
   */
  public createArticleFavorite(slug: string, options?: any) {
    return FavoritesApiFp(this.configuration).createArticleFavorite(
      slug,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Unfavorite an article. Auth is required
   * @summary Unfavorite an article
   * @param {string} slug Slug of the article that you want to unfavorite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FavoritesApi
   */
  public deleteArticleFavorite(slug: string, options?: any) {
    return FavoritesApiFp(this.configuration).deleteArticleFavorite(
      slug,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Follow a user by username
     * @summary Follow a user
     * @param {string} username Username of the profile you want to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUserByUsername(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling followUserByUsername.'
        )
      }
      const localVarPath = `/profiles/{username}/follow`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a profile of a user of the system. Auth is optional
     * @summary Get a profile
     * @param {string} username Username of the profile to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUsername(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling getProfileByUsername.'
        )
      }
      const localVarPath = `/profiles/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Unfollow a user by username
     * @summary Unfollow a user
     * @param {string} username Username of the profile you want to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUserByUsername(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling unfollowUserByUsername.'
        )
      }
      const localVarPath = `/profiles/{username}/follow`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Follow a user by username
     * @summary Follow a user
     * @param {string} username Username of the profile you want to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUserByUsername(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileResponse> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(
        configuration
      ).followUserByUsername(username, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get a profile of a user of the system. Auth is optional
     * @summary Get a profile
     * @param {string} username Username of the profile to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUsername(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileResponse> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(
        configuration
      ).getProfileByUsername(username, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Unfollow a user by username
     * @summary Unfollow a user
     * @param {string} username Username of the profile you want to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUserByUsername(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileResponse> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(
        configuration
      ).unfollowUserByUsername(username, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Follow a user by username
     * @summary Follow a user
     * @param {string} username Username of the profile you want to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUserByUsername(username: string, options?: any) {
      return ProfileApiFp(configuration).followUserByUsername(
        username,
        options
      )(fetch, basePath)
    },
    /**
     * Get a profile of a user of the system. Auth is optional
     * @summary Get a profile
     * @param {string} username Username of the profile to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUsername(username: string, options?: any) {
      return ProfileApiFp(configuration).getProfileByUsername(
        username,
        options
      )(fetch, basePath)
    },
    /**
     * Unfollow a user by username
     * @summary Unfollow a user
     * @param {string} username Username of the profile you want to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUserByUsername(username: string, options?: any) {
      return ProfileApiFp(configuration).unfollowUserByUsername(
        username,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
  /**
   * Follow a user by username
   * @summary Follow a user
   * @param {string} username Username of the profile you want to follow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public followUserByUsername(username: string, options?: any) {
    return ProfileApiFp(this.configuration).followUserByUsername(
      username,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get a profile of a user of the system. Auth is optional
   * @summary Get a profile
   * @param {string} username Username of the profile to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public getProfileByUsername(username: string, options?: any) {
    return ProfileApiFp(this.configuration).getProfileByUsername(
      username,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Unfollow a user by username
   * @summary Unfollow a user
   * @param {string} username Username of the profile you want to unfollow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public unfollowUserByUsername(username: string, options?: any) {
    return ProfileApiFp(this.configuration).unfollowUserByUsername(
      username,
      options
    )(this.fetch, this.basePath)
  }
}

/**
 * UserAndAuthenticationApi - fetch parameter creator
 * @export
 */
export const UserAndAuthenticationApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Register a new user
     * @summary Register a new user
     * @param {NewUserRequest} body Details of the new user to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: NewUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createUser.'
        )
      }
      const localVarPath = `/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'NewUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Gets the currently logged-in user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options: any = {}): FetchArgs {
      const localVarPath = `/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Login for existing user
     * @summary Existing user login
     * @param {LoginUserRequest} body Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(body: LoginUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling login.'
        )
      }
      const localVarPath = `/users/login`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'LoginUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updated user information for current user
     * @summary Update current user
     * @param {UpdateUserRequest} body User details to update. At least **one** field is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCurrentUser.'
        )
      }
      const localVarPath = `/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Token required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UpdateUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserAndAuthenticationApi - functional programming interface
 * @export
 */
export const UserAndAuthenticationApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     * Register a new user
     * @summary Register a new user
     * @param {NewUserRequest} body Details of the new user to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body: NewUserRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = UserAndAuthenticationApiFetchParamCreator(
        configuration
      ).createUser(body, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Gets the currently logged-in user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = UserAndAuthenticationApiFetchParamCreator(
        configuration
      ).getCurrentUser(options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Login for existing user
     * @summary Existing user login
     * @param {LoginUserRequest} body Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      body: LoginUserRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = UserAndAuthenticationApiFetchParamCreator(
        configuration
      ).login(body, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Updated user information for current user
     * @summary Update current user
     * @param {UpdateUserRequest} body User details to update. At least **one** field is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(
      body: UpdateUserRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = UserAndAuthenticationApiFetchParamCreator(
        configuration
      ).updateCurrentUser(body, options)
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * UserAndAuthenticationApi - factory interface
 * @export
 */
export const UserAndAuthenticationApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Register a new user
     * @summary Register a new user
     * @param {NewUserRequest} body Details of the new user to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: NewUserRequest, options?: any) {
      return UserAndAuthenticationApiFp(configuration).createUser(
        body,
        options
      )(fetch, basePath)
    },
    /**
     * Gets the currently logged-in user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any) {
      return UserAndAuthenticationApiFp(configuration).getCurrentUser(options)(
        fetch,
        basePath
      )
    },
    /**
     * Login for existing user
     * @summary Existing user login
     * @param {LoginUserRequest} body Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(body: LoginUserRequest, options?: any) {
      return UserAndAuthenticationApiFp(configuration).login(body, options)(
        fetch,
        basePath
      )
    },
    /**
     * Updated user information for current user
     * @summary Update current user
     * @param {UpdateUserRequest} body User details to update. At least **one** field is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(body: UpdateUserRequest, options?: any) {
      return UserAndAuthenticationApiFp(configuration).updateCurrentUser(
        body,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * UserAndAuthenticationApi - object-oriented interface
 * @export
 * @class UserAndAuthenticationApi
 * @extends {BaseAPI}
 */
export class UserAndAuthenticationApi extends BaseAPI {
  /**
   * Register a new user
   * @summary Register a new user
   * @param {NewUserRequest} body Details of the new user to register
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAndAuthenticationApi
   */
  public createUser(body: NewUserRequest, options?: any) {
    return UserAndAuthenticationApiFp(this.configuration).createUser(
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Gets the currently logged-in user
   * @summary Get current user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAndAuthenticationApi
   */
  public getCurrentUser(options?: any) {
    return UserAndAuthenticationApiFp(this.configuration).getCurrentUser(
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Login for existing user
   * @summary Existing user login
   * @param {LoginUserRequest} body Credentials to use
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAndAuthenticationApi
   */
  public login(body: LoginUserRequest, options?: any) {
    return UserAndAuthenticationApiFp(this.configuration).login(body, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Updated user information for current user
   * @summary Update current user
   * @param {UpdateUserRequest} body User details to update. At least **one** field is required.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAndAuthenticationApi
   */
  public updateCurrentUser(body: UpdateUserRequest, options?: any) {
    return UserAndAuthenticationApiFp(this.configuration).updateCurrentUser(
      body,
      options
    )(this.fetch, this.basePath)
  }
}
